# Документация по архитектуре

## Обзор системы

Сканер вирусов - это приложение на C++, которое рекурсивно сканирует директории, вычисляет MD5 хэши файлов и сравнивает их с базой данных известных сигнатур вредоносного ПО. Система спроектирована как DLL библиотека с CLI фронтендом.

## Архитектурные слои

```
┌─────────────────────────────────────────────────────────┐
│                  Слой представления                      │
│                     (scannerCli)                         │
│  ┌──────────┐  ┌────────────┐  ┌──────────────────┐   │
│  │  main.cpp │  │ LineParser │  │     Config       │   │
│  └──────────┘  └────────────┘  └──────────────────┘   │
└─────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────┐
│                 Слой приложения                          │
│                      (scanner DLL)                       │
│  ┌──────────────────────────────────────────────────┐  │
│  │            ScannerImpl (Оркестратор)              │  │
│  │  • InitializeDependencies()                       │  │
│  │  • ExecuteScan()                                  │  │
│  │  • CollectFiles()                                 │  │
│  │  • ProcessFile()                                  │  │
│  └──────────────────────────────────────────────────┘  │
│                          │                               │
│         ┌────────────────┼────────────────┐            │
│         ▼                ▼                ▼            │
│  ┌────────────┐  ┌──────────────┐  ┌──────────┐      │
│  │  Logger    │  │ HashDatabase │  │ThreadPool│      │
│  └────────────┘  └──────────────┘  └──────────┘      │
└─────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────┐
│              Инфраструктурный слой                       │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐ │
│  │ MD5Calculator│  │    Utils     │  │  Constants   │ │
│  └──────────────┘  └──────────────┘  └──────────────┘ │
│  ┌──────────────────────────────────────────────────┐  │
│  │         SettingsValidator                         │  │
│  └──────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────┐
│                 Внешние зависимости                      │
│  ┌──────────┐  ┌──────────────┐  ┌──────────────────┐ │
│  │ OpenSSL  │  │  Filesystem  │  │  Threading (STL) │ │
│  └──────────┘  └──────────────┘  └──────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

## Ответственность компонентов

### Слой представления (scannerCli)

#### main.cpp
- **Ответственность**: Точка входа приложения
- **Зависимости**: Config, LineParser, Scanner API
- **Ключевые функции**:
  - Парсинг аргументов командной строки
  - Конфигурация настроек сканера
  - Выполнение сканирования
  - Отображение результатов

#### Config
- **Ответственность**: Управление конфигурацией и валидация
- **Состояние**: Путь сканирования, путь к базе данных, путь к логу, режим отладки
- **Ключевые методы**:
  - `SetHashDatabasePath()`: Валидация и сохранение пути к базе данных
  - `SetLogPath()`: Валидация и сохранение пути к логу
  - `SetScanPath()`: Валидация и сохранение директории сканирования
  - `GetXxx()`: Получение значений конфигурации

#### LineParser
- **Ответственность**: Парсинг аргументов командной строки
- **Зависимости**: Config
- **Ключевые методы**:
  - `parse()`: Парсинг argc/argv в Config
  - `printHelp()`: Отображение информации об использовании

### Слой приложения (scanner DLL)

#### ScannerImpl (Оркестратор)
- **Ответственность**: Координация рабочего процесса сканирования
- **Паттерн**: Фасад + Шаблонный метод
- **Состояние**:
  - Статус сканирования (атомарный)
  - Статистика (атомарные счётчики)
  - Зависимости (Logger, HashDatabase, ThreadPool)
  - Результаты (потокобезопасный вектор)
- **Ключевые методы**:
  - `Scan()`: Выполнение сканирования без прогресса
  - `ScanWithProgress()`: Выполнение сканирования с callback прогресса
  - `InitializeDependencies()`: Настройка logger, database, thread pool
  - `ExecuteScan()`: Основной цикл сканирования
  - `CollectFiles()`: Сбор файлов для сканирования
  - `ProcessFile()`: Хэширование и проверка одного файла
  - `Stop()`: Корректное завершение

**Проектные решения**:
- Использует атомарные переменные для потокобезопасных счётчиков
- Сбор результатов защищён мьютексом
- Валидация настроек перед запуском
- Повторный выброс исключений после логирования (быстрый отказ)

#### Logger
- **Ответственность**: Потокобезопасное логирование в файл
- **Паттерн**: Фабричный метод
- **Состояние**: Выходной файловый поток, мьютекс
- **Ключевые методы**:
  - `Create()`: Фабричный метод для безопасного конструирования
  - `LogMalware()`: Логирование обнаруженного вредоносного ПО
  - `LogError()`: Логирование сообщений об ошибках
  - `LogInfo()`: Логирование информационных сообщений
  - `Flush()`: Принудительная запись на диск

**Проектные решения**:
- Приватный конструктор (использовать фабрику)
- Отдельная запись заголовка сессии
- Все методы потокобезопасны
- Автоматический flush при уничтожении

#### HashDatabase
- **Ответственность**: Хранение и поиск сигнатур вредоносного ПО
- **Состояние**: Отображение хэш-вердикт, мьютекс
- **Ключевые методы**:
  - `LoadFromCSV()`: Парсинг и валидация CSV базы данных
  - `IsMalicious()`: Потокобезопасный поиск хэша
  - `GetSize()`: Возврат размера базы данных

**Проектные решения**:
- Валидация формата хэша (32 hex символа)
- Регистронезависимый поиск
- Пропуск некорректных записей
- Применение лимита размера (10М записей)

#### ThreadPool
- **Ответственность**: Параллельное выполнение задач
- **Паттерн**: Пул потоков
- **Состояние**: Рабочие потоки, очередь задач, примитивы синхронизации
- **Ключевые методы**:
  - `Enqueue()`: Добавление задачи в очередь
  - `Wait()`: Блокировка до завершения всех задач
  - `Stop()`: Корректное завершение

**Проектные решения**:
- Пул фиксированного размера (без динамического изменения)
- FIFO очередь задач
- Условные переменные для синхронизации
- Корректное завершение при уничтожении

### Инфраструктурный слой

#### MD5Calculator
- **Ответственность**: Хэширование файлов
- **Паттерн**: Статический утилитный класс
- **Ключевые методы**:
  - `CalculateFile()`: Вычисление MD5 хэша файла
  - `BytesToHex()`: Преобразование бинарных данных в hex строку

**Проектные решения**:
- Проверка лимита размера файла перед хэшированием
- Использование фиксированного буфера 64 КБ
- Выброс исключения для слишком больших файлов

#### SettingsValidator
- **Ответственность**: Валидация входных данных
- **Паттерн**: Статический валидатор
- **Ключевые методы**:
  - `Validate()`: Валидация всех настроек
  - `ValidatePath()`: Проверка директории сканирования
  - `ValidateDatabasePath()`: Проверка файла базы данных
  - `ValidateThreadCount()`: Проверка количества потоков

**Проектные решения**:
- Возвращает `std::optional<std::string>` (сообщение об ошибке или nullopt)
- Комплексные проверки (существование, тип, права доступа)
- Использует константы для лимитов

#### Utils
- **Ответственность**: Общие утилитные функции
- **Паттерн**: Статический утилитный класс
- **Ключевые методы**:
  - `ToLower()`: Преобразование строки в нижний регистр
  - `Trim()`: Удаление начальных/конечных пробелов
  - `IsFileReadable()`: Проверка доступности файла
  - `GetHardwareConcurrency()`: Получение количества ядер CPU

#### Constants
- **Ответственность**: Централизованная конфигурация
- **Паттерн**: Пространство имён с constexpr значениями
- **Ключевые константы**:
  - Лимиты файлов (размер, глубина пути)
  - Лимиты потоков (мин, макс)
  - Параметры хэширования (размер буфера, длина)
  - Лимиты базы данных (макс записей)

## Поток данных

### Поток выполнения сканирования

```
1. Парсинг CLI
   main() → LineParser::parse() → Config::SetXxx()
   
2. Валидация
   ScannerImpl::ScanWithProgress()
   └─→ SettingsValidator::Validate()
   
3. Инициализация
   ScannerImpl::InitializeDependencies()
   ├─→ Logger::Create()
   ├─→ HashDatabase::LoadFromCSV()
   └─→ ThreadPool(threadCount)
   
4. Сбор файлов
   ScannerImpl::ExecuteScan()
   └─→ CollectFiles()
       ├─→ recursive_directory_iterator
       ├─→ Проверка размера файла
       └─→ Добавление в вектор
   
5. Параллельная обработка
   Для каждого файла:
   ThreadPool::Enqueue()
   └─→ ProcessFile()
       ├─→ Utils::IsFileReadable()
       ├─→ MD5Calculator::CalculateFile()
       ├─→ HashDatabase::IsMalicious()
       └─→ Logger::LogMalware() (если вредоносный)
   
6. Ожидание завершения
   ThreadPool::Wait()
   
7. Возврат результатов
   Построение ScanResult
   └─→ Возврат вызывающему коду
```

### Поток обработки ошибок

```
Возникновение ошибки
    │
    ├─→ Ошибка валидации
    │   └─→ Выброс до начала сканирования
    │
    ├─→ Фатальная ошибка (загрузка БД, создание logger)
    │   ├─→ Логирование ошибки
    │   ├─→ Увеличение счётчика ошибок
    │   └─→ Повторный выброс вызывающему коду
    │
    └─→ Ошибка обработки файла
        ├─→ Логирование ошибки
        ├─→ Увеличение счётчика ошибок
        └─→ Продолжение со следующим файлом
```

## Потокобезопасность

### Потокобезопасные компоненты
- **ScannerImpl**: Атомарные счётчики, результаты защищены мьютексом
- **Logger**: Записи в файл защищены мьютексом
- **HashDatabase**: Доступ к map защищён мьютексом
- **ThreadPool**: Условные переменные и мьютексы

### Точки синхронизации
1. **Сбор результатов**: `resultMutex_` защищает вектор `detectedMalware_`
2. **Callback прогресса**: `progressMutex_` защищает вызов callback
3. **Логирование**: `mutex_` в Logger защищает записи в файл
4. **Поиск в базе**: `mutex_` в HashDatabase защищает доступ к map
5. **Очередь задач**: `queueMutex_` в ThreadPool защищает очередь задач

## Стратегия обработки ошибок

### Ошибки валидации
- **Когда**: До начала сканирования
- **Как**: `SettingsValidator::Validate()` возвращает сообщение об ошибке
- **Действие**: Выброс исключения, сканирование не начинается

### Фатальные ошибки
- **Когда**: Во время инициализации (logger, database)
- **Как**: Выброс исключения
- **Действие**: Логирование, увеличение счётчика, повторный выброс

### Восстанавливаемые ошибки
- **Когда**: Во время обработки файлов
- **Как**: Исключение перехватывается в `ProcessFile()`
- **Действие**: Логирование, увеличение счётчика, продолжение

### Ошибки прав доступа
- **Когда**: Во время сбора файлов
- **Как**: Проверка `std::error_code`
- **Действие**: Логирование, пропуск файла, продолжение

## Лимиты конфигурации

| Лимит | Значение | Обоснование |
|-------|----------|-------------|
| MAX_FILE_SIZE | 100 МБ | Предотвращение исчерпания памяти |
| MAX_PATH_DEPTH | 100 | Предотвращение бесконечной рекурсии |
| MIN_THREAD_COUNT | 1 | Минимум один поток требуется |
| MAX_THREAD_COUNT | 256 | Разумная верхняя граница |
| HASH_BUFFER_SIZE | 64 КБ | Оптимально для большинства систем |
| MAX_DATABASE_ENTRIES | 10М | Предотвращение чрезмерного использования памяти |
| MD5_HASH_LENGTH | 32 | MD5 производит 32 hex символа |

## Публичный API

### C++ API (scannerApi.h)

```cpp
namespace Scanner {
    // Структуры данных
    struct MalwareInfo { ... };
    struct ScanResult { ... };
    struct ScanSettings { ... };
    
    // Тип callback
    using ProgressCallback = std::function<void(const std::string&, size_t)>;
    
    // Интерфейс
    class IScanner {
        virtual ScanResult Scan(const ScanSettings&) = 0;
        virtual ScanResult ScanWithProgress(const ScanSettings&, ProgressCallback) = 0;
        virtual void Stop() = 0;
        virtual bool IsScanning() const = 0;
    };
}
```

### C API (для DLL)

```cpp
extern "C" {
    SCANNER_API Scanner::IScanner* CreateScanner();
    SCANNER_API void DestroyScanner(Scanner::IScanner*);
}
```

## Использованные паттерны проектирования

1. **Фабричный метод**: `Logger::Create()`
2. **Фасад**: `ScannerImpl` скрывает сложность
3. **Шаблонный метод**: `ScanWithProgress()` вызывает `Scan()`
4. **Пул потоков**: Класс `ThreadPool`
5. **RAII**: Все ресурсы управляются умными указателями
6. **Внедрение зависимостей**: (Частичное - зависимости создаются внутри)

## Будущие улучшения

### Рекомендуемые (P1)
1. **Полное внедрение зависимостей**: Передача зависимостей в конструктор ScannerImpl
2. **Извлечение интерфейсов**: Создание ILogger, IHashDatabase, IThreadPool
3. **Паттерн стратегии**: Поддержка нескольких алгоритмов хэширования
4. **Тип Result**: Использование std::expected вместо исключений

### Опциональные (P2)
1. **Паттерн наблюдателя**: Лучшая отчётность о прогрессе
2. **Паттерн команды**: Отмена/повтор операций сканирования
3. **Паттерн строителя**: Fluent API для ScanSettings
4. **Паттерн посетителя**: Различные стратегии сканирования

## Стратегия тестирования

### Юнит-тесты
- **SettingsValidator**: Все пути валидации
- **HashDatabase**: Парсинг CSV, поиск, валидация
- **Utils**: Операции со строками, системные запросы
- **Constants**: Проверки на разумность

### Интеграционные тесты
- **Полное сканирование**: End-to-end с реальными файлами
- **Callback прогресса**: Проверка вызова callback
- **Обработка ошибок**: Неверные входные данные, отсутствующие файлы
- **Конкурентность**: Множество потоков, состояния гонки

### Тесты производительности (Будущее)
- Большие деревья директорий (10K+ файлов)
- Большие базы данных (1М+ сигнатур)
- Масштабирование потоков (1, 2, 4, 8, 16 потоков)

## Зависимости

### Внешние
- **OpenSSL**: MD5 хэширование (libcrypto)
- **C++17 STL**: Filesystem, threading, контейнеры
- **GoogleTest**: Фреймворк юнит-тестирования

### Внутренние
- **scanner**: Основная библиотека (DLL)
- **scannerCli**: Интерфейс командной строки (EXE)
- **tests**: Набор тестов (EXE)

## Система сборки

### Структура CMake
```
CMakeLists.txt (корень)
├── scanner/CMakeLists.txt (DLL)
├── scannerCli/CMakeLists.txt (EXE)
└── tests/CMakeLists.txt (Тесты)
```

### Цели сборки
- **scanner**: Разделяемая библиотека (DLL/SO)
- **scanner_exe**: CLI исполняемый файл
- **unit_tests**: Исполняемый файл тестов

### Поддержка платформ
- **Windows**: Visual Studio 2022, MSVC
- **Linux**: GCC 7+, Clang 6+
- **macOS**: Clang (Xcode)

## Характеристики производительности

### Временная сложность
- **Сбор файлов**: O(n) где n = количество файлов
- **Вычисление хэша**: O(m) где m = размер файла
- **Поиск в базе**: O(1) в среднем (hash map)
- **Общая**: O(n * m) с распараллеливанием

### Пространственная сложность
- **Список файлов**: O(n) - хранит все пути файлов
- **База данных**: O(d) где d = размер базы данных
- **Результаты**: O(k) где k = количество вредоносных файлов
- **Пул потоков**: O(t) где t = количество потоков

### Масштабируемость
- **Горизонтальная**: Ограничена ядрами CPU
- **Вертикальная**: Ограничена размером файла (макс 100 МБ)
- **База данных**: Ограничена памятью (макс 10М записей)

## Соображения безопасности

### Валидация входных данных
- Все пути валидируются перед использованием
- Размеры файлов проверяются перед обработкой
- Формат хэша валидируется
- Количество потоков ограничено

### Обработка прав доступа
- Пропуск файлов без прав на чтение
- Пропуск директорий без прав на выполнение
- Логирование ошибок прав доступа

### Лимиты ресурсов
- Лимит размера файла (100 МБ)
- Лимит размера базы данных (10М записей)
- Лимит количества потоков (256)
- Лимит глубины пути (100)

### Смягчённые векторы атак
- **Обход пути**: Валидированные пути
- **DoS**: Лимиты размера файлов и базы данных
- **Исчерпание памяти**: Ограниченные коллекции
- **Бесконечные циклы**: Лимит глубины пути

## Мониторинг и наблюдаемость

### Уровни логирования
- **INFO**: События жизненного цикла сканирования
- **ERROR**: Восстанавливаемые ошибки
- **MALWARE**: Обнаруженные угрозы

### Собираемые метрики
- Всего обработано файлов
- Обнаружено вредоносных файлов
- Встречено ошибок
- Время выполнения
